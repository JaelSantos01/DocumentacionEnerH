[
  {
    "objectID": "include/interfaz.html",
    "href": "include/interfaz.html",
    "title": "Desarrollo de la Interfaz",
    "section": "",
    "text": "A continuación explicará el desarrollo de la interfaz de Ener-Habitat:\nLa declaración de app_ui, sirve para definir la interfaz del usuario, donde se describirá la vista de la aplicación, es decir, los elementos interactivos (botones, gráficas, tablas, etc.) que estarán presentes y como estarán organizados.\n## Ejemplo para conocer el uso de app_ui\nfrom Shiny import App, ui, render, reactive \n\napp_ui = ui.page_fluid(\"Hello Shiny!\")\n\ndef server(input, output, session):\n\napp = App(app_ui, server)\n\n\nUna vez, explicado el uso de app_ui en Shiny, se comenzará con el desarrollo de la interfaz, declarando una ui.page_sidebar, junto con un acordeón, para generar una barra lateral indicando el nombre del sistema en este caso “Ener-Habitat”, y para colocar en el primer acordeón una función que contendrá varios inputs para que el usuario seleccione cada condición con la cual se generará el gráfico de la simulación, dependiendo el tipo de sistema que desee realizar:\n## Parte de la interfaz, que manda a llamar la función \n## \"left_controls\"\nfrom Shiny import App, ui, render, reactive \n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.accordion(\n            ui.accordion_panel(\n                \"Cambios\",\n                ui.output_ui(\"left_controls\"),\n            ),\n        ),\n    )\n)        \n\n\n\nContinuando con el desarrollo de la interfaz, se declaró un segundo acordeón que contendrá otra sección de inputs, mostrado cada uno en la función “controls_top”, junto con un input selector, para seleccionar el tipo de sistema “Con capa homogénea” y/o “Sin capa homogénea” (la cual aún sigue en desarrollo). LLamando a una lista de diccionarios, junto con un input númerico el cual el usuario seleccionará el número de sistemas que desea realizar (como minímo 1, de 1 en 1, máximo 5), y por último, un nuevo acordeón que manda a llamar la función “controls_rigth”, junto con un botón que contará las simulaciones realizadas.\n## Parte de la interfaz, que manda a llamar la función \n## \"controls_top\" & \"controls_rigth\"\nfrom Shiny import App, ui, render, reactive \n\napp_ui = ui.page_sidebar(\n\n    ui.accordion(\n        ui.accordion_panel(\n            \"Selección\",\n            ui.output_ui(\"controls_top\"),\n                ui.input_select(  \n                    \"type\",  \n                    \"Tipo de sistema:\",  \n                    choices= list(type_sistem.keys()),  \n                ),\n        ),\n    ),\n    ui.input_numeric(\"sistemas\", \"Número de sistemas:\", \n    value=1, min=1, max=5),  \n    ui.accordion(\n        ui.accordion_panel(\n            \"Datos\",\n            ui.output_ui(\"controls_rigth\")\n        )\n    ),\n    ui.input_action_button(\"update\", \"correr\"),\n),        \n\n\n\nPara comenzar con la parte de la interfaz, donde se visualizará un panel por cada sección de los graficos, tablas, etc. Se declaró un ui.navset_card_underline, para dividir cada seccion con paneles (nav.panel), los cuales contendrán diferentes secciones de información visible para el usuario como: la gráfica de temperatura, la segunda gráfica de radiación, los resultados, el DataFrame junto con el botón de descarga y por último el panel de la documentación.\n\n\n\n\n\n\nEjemplo de uso ui.navset_card_underline:\n\n\n\n## Parte de la interfaz, que renderiza cada sección \n## de panel con el nombre \"Datos Graficados\"\nfrom Shiny import App, ui, render, reactive \n\napp_ui = ui.page_sidebar(\n\n    ui.navset_card_underline(\n        ui.nav_panel(\"Temperaturas\", output_widget(\"temperatura\")),\n        ui.nav_panel(\"Radiación\", output_widget(\"radiacion\")),\n        ui.nav_panel(\"Resultados\", ui.output_text(\"resultados\")),\n        ui.nav_panel(\"Datos\", ui.output_data_frame(\"get_day_data\"),\n        ui.download_button(\"downloadData\", \"Download\")),\n        ui.nav_panel(\"Documentacion\", ui.output_ui(\"documentacion\")),\n\n        title=\"Datos Gráficados\",\n    ),\n\n    ui.include_css(app_dir / \"styles.css\"),\n    fillable=True,\n),        \nDonde la parte inferior contiene la declaración y ubicación del archivo css para el tipo de estilo que contiene la interfaz, al igual que permitimos con “fillable = True” que el usuario ingrese o edite datos en ese campo.\n\n\n\nPara terminar con el desarrollo de la interfaz, se generó un div para indicar que el título de la interfaz seria “Renovacion de Ener-Habitat” e indicandole que junto con el título se anadiria una imagen que redireccionara a la presente documentación.\n## Parte final de la interfaz\n\nfrom Shiny import App, ui, render, reactive \n\napp_ui = ui.page_sidebar(\n\n    title=ui.tags.div(\n        \"Renovacion de Ener-Habitat\",\n        ui.a(\n            ui.img(src=\"logo.png\", \n            height=\"25px\", width=\"25px\"),\n            href=\"https://example.com\",\n            target=\"_blank\",\n            style=\"margin-left: 10px;\" \n        ),\n    ),\n),",
    "crumbs": [
      "Desarrollo de interfaz"
    ]
  },
  {
    "objectID": "include/interfaz.html#parte-1",
    "href": "include/interfaz.html#parte-1",
    "title": "Desarrollo de la Interfaz",
    "section": "",
    "text": "Una vez, explicado el uso de app_ui en Shiny, se comenzará con el desarrollo de la interfaz, declarando una ui.page_sidebar, junto con un acordeón, para generar una barra lateral indicando el nombre del sistema en este caso “Ener-Habitat”, y para colocar en el primer acordeón una función que contendrá varios inputs para que el usuario seleccione cada condición con la cual se generará el gráfico de la simulación, dependiendo el tipo de sistema que desee realizar:\n## Parte de la interfaz, que manda a llamar la función \n## \"left_controls\"\nfrom Shiny import App, ui, render, reactive \n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.accordion(\n            ui.accordion_panel(\n                \"Cambios\",\n                ui.output_ui(\"left_controls\"),\n            ),\n        ),\n    )\n)",
    "crumbs": [
      "Desarrollo de interfaz"
    ]
  },
  {
    "objectID": "include/interfaz.html#parte-2",
    "href": "include/interfaz.html#parte-2",
    "title": "Desarrollo de la Interfaz",
    "section": "",
    "text": "Continuando con el desarrollo de la interfaz, se declaró un segundo acordeón que contendrá otra sección de inputs, mostrado cada uno en la función “controls_top”, junto con un input selector, para seleccionar el tipo de sistema “Con capa homogénea” y/o “Sin capa homogénea” (la cual aún sigue en desarrollo). LLamando a una lista de diccionarios, junto con un input númerico el cual el usuario seleccionará el número de sistemas que desea realizar (como minímo 1, de 1 en 1, máximo 5), y por último, un nuevo acordeón que manda a llamar la función “controls_rigth”, junto con un botón que contará las simulaciones realizadas.\n## Parte de la interfaz, que manda a llamar la función \n## \"controls_top\" & \"controls_rigth\"\nfrom Shiny import App, ui, render, reactive \n\napp_ui = ui.page_sidebar(\n\n    ui.accordion(\n        ui.accordion_panel(\n            \"Selección\",\n            ui.output_ui(\"controls_top\"),\n                ui.input_select(  \n                    \"type\",  \n                    \"Tipo de sistema:\",  \n                    choices= list(type_sistem.keys()),  \n                ),\n        ),\n    ),\n    ui.input_numeric(\"sistemas\", \"Número de sistemas:\", \n    value=1, min=1, max=5),  \n    ui.accordion(\n        ui.accordion_panel(\n            \"Datos\",\n            ui.output_ui(\"controls_rigth\")\n        )\n    ),\n    ui.input_action_button(\"update\", \"correr\"),\n),",
    "crumbs": [
      "Desarrollo de interfaz"
    ]
  },
  {
    "objectID": "include/interfaz.html#parte-3",
    "href": "include/interfaz.html#parte-3",
    "title": "Desarrollo de la Interfaz",
    "section": "",
    "text": "Para comenzar con la parte de la interfaz, donde se visualizará un panel por cada sección de los graficos, tablas, etc. Se declaró un ui.navset_card_underline, para dividir cada seccion con paneles (nav.panel), los cuales contendrán diferentes secciones de información visible para el usuario como: la gráfica de temperatura, la segunda gráfica de radiación, los resultados, el DataFrame junto con el botón de descarga y por último el panel de la documentación.\n\n\n\n\n\n\nEjemplo de uso ui.navset_card_underline:\n\n\n\n## Parte de la interfaz, que renderiza cada sección \n## de panel con el nombre \"Datos Graficados\"\nfrom Shiny import App, ui, render, reactive \n\napp_ui = ui.page_sidebar(\n\n    ui.navset_card_underline(\n        ui.nav_panel(\"Temperaturas\", output_widget(\"temperatura\")),\n        ui.nav_panel(\"Radiación\", output_widget(\"radiacion\")),\n        ui.nav_panel(\"Resultados\", ui.output_text(\"resultados\")),\n        ui.nav_panel(\"Datos\", ui.output_data_frame(\"get_day_data\"),\n        ui.download_button(\"downloadData\", \"Download\")),\n        ui.nav_panel(\"Documentacion\", ui.output_ui(\"documentacion\")),\n\n        title=\"Datos Gráficados\",\n    ),\n\n    ui.include_css(app_dir / \"styles.css\"),\n    fillable=True,\n),        \nDonde la parte inferior contiene la declaración y ubicación del archivo css para el tipo de estilo que contiene la interfaz, al igual que permitimos con “fillable = True” que el usuario ingrese o edite datos en ese campo.",
    "crumbs": [
      "Desarrollo de interfaz"
    ]
  },
  {
    "objectID": "include/interfaz.html#parte-final",
    "href": "include/interfaz.html#parte-final",
    "title": "Desarrollo de la Interfaz",
    "section": "",
    "text": "Para terminar con el desarrollo de la interfaz, se generó un div para indicar que el título de la interfaz seria “Renovacion de Ener-Habitat” e indicandole que junto con el título se anadiria una imagen que redireccionara a la presente documentación.\n## Parte final de la interfaz\n\nfrom Shiny import App, ui, render, reactive \n\napp_ui = ui.page_sidebar(\n\n    title=ui.tags.div(\n        \"Renovacion de Ener-Habitat\",\n        ui.a(\n            ui.img(src=\"logo.png\", \n            height=\"25px\", width=\"25px\"),\n            href=\"https://example.com\",\n            target=\"_blank\",\n            style=\"margin-left: 10px;\" \n        ),\n    ),\n),",
    "crumbs": [
      "Desarrollo de interfaz"
    ]
  },
  {
    "objectID": "include/funciones.html",
    "href": "include/funciones.html",
    "title": "Funciones generales",
    "section": "",
    "text": "A continuación se explicarán y se mostrarán las funciones que contiene dicho sistema, para completar el desarrollo de ejecución de la interfaz:\n\n\nSe generó una función para obtener todo el contenido del archivo de lugares .ini, donde dicho contenido será utilizado para la elaboración de los gráficos y maipulación de datos en el DataFrame.\ndef cargar_caracteristicas(lugar):\n    lugar_config = config[lugar]\n    return {\n        \"lat\": lugar_config.getfloat('lat'),\n        \"lon\": lugar_config.getfloat('lon'),\n        \"alt\": lugar_config.getint('altitude'),\n        \"epw\": lugar_config['f_epw']\n}\n\n\n\nLa siguiente función se creó para obtener la ruta del archivo EPW, que contiene cada lugar. Está función extrae del archivo luagres.ini, la característica “f_epw” la ruta del EPW, para que al momento de que el usuario seleccione el lugar se extraíga el EPW correcto del lugar en específico.\ndef ruta(lugar):\n    f_epw = cargar_caracteristicas(lugar)\n    epwP = f_epw['epw']\n    divi = epwP.split(\"_\")\n    pa = divi[0].replace('data/', '')\n    pais = pa.capitalize()\n    es = divi[1]\n    estado = es.capitalize()\n    ciudad = divi[2].replace('.epw', '')\n    ruta = f\"./data/{pa}_{es}_{ciudad}.epw\"\n    return ruta\n\n\n\nLa función que se muestra a continuación es para crear los inputs del apartado “Cambios”, con los cuales el usuario podrá interactuar con ellos para simular en base a sus necesidades. Validando que tipo de sistema constructivo el usuario desea realizar (“Homogéno o No homogéneo”).\ndef controls_left(type,lugares,meses_dict, location, orientacion,absortance):\n    if type == 1 :\n        return ui.TagList(\n            ui.input_select(\"place\", \"Lugar:\", \n            choices=lugares),\n            ui.input_selectize(\"periodo\", \"Mes:\", \n            choices=list(meses_dict.keys())),\n            ui.input_select(\"ubicacion\", \"Ubicación:\", \n            choices=list(location.keys())),\n            ui.output_ui(\"ubicacion_orientacion\")\n        )\n    elif type == 2 :\n        return ui.TagList(\n            ui.input_select(\"place\", \"Lugar:\", \n            choices=lugares),\n            ui.input_selectize(\"periodo\", \"Mes:\", \n            choices=list(meses_dict.keys())),\n            ui.input_select(\"ubicacion\", \"Ubicación:\", \n            choices=list(location.keys())),\n            ui.input_select(\"orientacion\", \"Orientación:\", \n            choices=list(orientacion.keys())),\n            ui.input_select(\"absortancia\",\"Absortancia:\", \n            choices=list(absortance.keys())),\n            ui.output_ui(\"absortancia_f\"),\n        )\n    return None\n\n\n\nEsta función se generó para que al momento de validar la ubicación la orientación se mostrará o se ocultará. Al igual que se manda a llamar una nueva función “absortancia_f”.\ndef orientacion_disable(ubicacion,  orientacion, absortance):\n    if ubicacion == \"Techo\":\n        return ui.TagList(\n                ui.input_select(\"absortancia\", \"Absortancia:\", \n                choices=list(absortance.keys())),\n                ui.output_ui(\"absortancia_f\")\n            ) \n    else: \n        return ui.TagList(\n                ui.input_select(\"orientacion\", \"Orientación:\", \n                choices=list(orientacion.keys())),\n                ui.input_select(\"absortancia\", \"Absortancia:\", \n                choices=list(absortance.keys())),\n                ui.output_ui(\"absortancia_f\")\n        )  \n\n\n\nEsta función genera un input numérico para que al momento de que la Abosortancia se muestre, el valor predeterminado por tipo de material así como la opción de seleccionar de Absortancia en caso de que no se tenga en la lista mostrada.\ndef absortance_value(value):\n        return ui.TagList(\n            ui.input_numeric(\"absortancia_value\", \"\", \n            value=value, min=0.10, max=1.0, step=0.01)  \n        ) \n\n\n\nEsta función muestra nuevos inputs para la sección de acordeón “Selección”, en base al tipo de sistema constructivo.\ndef top_controls(type):\n    if type == 1:\n        return ui.TagList(\n            ui.input_select(\"Conditional\", \"Condición:\", \n            choices=[\"Sin aire acondicionado\", \"Con aire acondicionado\"]),  \n        )\n    elif type == 2:\n        return ui.TagList(\n            ui.input_slider(\"capas\", \"Número de capas:\", 1, 5, 1),\n            ui.input_select(\"Conditional\", \"Condición:\", \n            choices=[\"Sin aire acondicionado\", \"Con aire acondicionado\"]),\n        )\n    return None\n\n\n\nLa siguiente función al igual que las anteriores, en base al tipo de sistema, se crean nuevas funciones o nuevos inputs. Para el tipo de sistema con capa homogénea, renderiza a una nueva función llamada “campos” y para el tipo de sistema sin capa homogéna (aún en desarrollo), se generan una lista de inputs.\ndef rigth_controls(type, materiales):\n    if type == 1:\n        return ui.TagList(\n            ui.output_ui(\"campos\")\n        )\n    elif type == 2:\n        return ui.TagList(\n            ui.HTML('&lt;img src=\"modelo.png\" \n            width=\"200\" height=\"90\"&gt;'),\n            ui.input_select(\"muro\", \"Material:\", \n            choices=materiales),\n            ui.layout_columns(\n                ui.input_numeric(\"e11\", \"e11\", value=0.1),\n                ui.input_numeric(\"a11\", \"a11\", value=0.1),\n            ),\n            ui.layout_columns(\n                ui.input_numeric(\"e21\", \"e21\", value=0.1),\n                ui.input_numeric(\"a21\", \"a21\", value=0.1),\n            ),\n            ui.layout_columns(\n                ui.input_numeric(\"e12\", \"e12\", value=0.1),\n                ui.input_numeric(\"a12\", \"a12\", value=0.1),\n            ),\n        )\n    return None\n\n\n\nEn esta función se genera la cantidad máx. de 5 sistemas constructivos, al momento de que el usuario ponga un número no válido de sistemas, se le mostrará un modal de error, donde le indique que solo se le permiten de 1 a 5 sistemas. Y si el usuario ingresa una cantidad correcta, entonces la función le genera el número que haya seleccionado, en una sección de acordeón nueva para cada sistema, donde contendrá un input numérico para seleccionar la cantidad de capas por sistema.\n\n\n\n\n\n\nSe 5 listas para generar la sección de acordeón por sistema (SC1,SC2,SC3,SC4,SC5)\n\n\n\ndef f_sistemas(num):\n    if num &gt; 5 or num &lt; 1 or num is None:\n        modal_content = \"Solo se permiten entre 1 y 5 \n        sistemas constructivos.\"\n        modal = ui.modal(modal_content, title=\"Error\", \n        easy_close=True)\n        ui.modal_show(modal)\n        return\n    else:\n        SC1 = ui.TagList(\n            ui.accordion(\n                ui.accordion_panel(\n                    \"Sistema constructivo 1:\",\n                    ui.input_numeric(\"capa_1\", \n                    \"Numero de capas:\", value=1, min=1, max=7),\n                    ui.output_ui(\"num_capas1\")\n                )\n            )\n        )\n        if num == 1:\n            return SC1\n        elif num == 2:\n            return SC1 + SC2\n        elif num == 3:\n            return SC1 + SC2 + SC3\n        elif num == 4:\n            return SC1 + SC2 + SC3 + SC4\n        elif num == 5:\n            return SC1 + SC2 + SC3 + SC4 + SC5\n\n\n\nEsta función genera la cantidad de capas por sistema que el usuario haya registrado en el input de la función anterior, validando el limíte del número de capas, al igual que la función anterior si el usuario ingresa un número no válido, entonces se mostrará un modal de error indicandole que ingrese el número correcto.\n\n\n\n\n\n\nSe generaron 5 funciones para cada sistema, teniendo la misma información solo cambiando el id de los inputs.\n\n\n\ndef info_capa1(capa, materiales, sistemas):\n    if capa &gt; 7 or capa &lt; 1 or capa is None:\n        modal_content = \"Solo se permiten entre 1 y 7 capas.\"\n        modal = ui.modal(modal_content, title=\"Error\", \n        easy_close=True)\n        ui.modal_show(modal)\n        return\n    else:\n        capas_ui = []\n        for i in range(capa):\n            capas_ui.append(\n                ui.layout_columns(\n                    ui.input_numeric(f\"espesor_SC1_{i+1}\", \n                    f\"Espesor {i+1} SC 1:\", value=0.010, max=0.9, \n                    step=0.01, min=0.010),\n                    ui.input_select(f\"material_SC1_{i+1}\", \n                    f\"Material {i+1} SC 1:\", choices=materiales)\n                )\n            )\n        return ui.TagList(*capas_ui) if capas_ui else ui.TagList()\n\n\n\nEstá función fue creada para generar la gráfica de “Temperatura”, donde nos visualza un grafico dependiendo los valores ingresados por el usuario, para generar un cálculo en base a ello.\ndef plot_T(dia):\n    fig = make_subplots(rows=1, cols=1)\n    df = dia.iloc[::600]\n    fig.add_trace(go.Scatter(x=df.index, y=df['Ta'], \n    mode='lines', name='Ta', line=dict(color='black'))\n    , row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Tsa'], \n    mode='lines', name='Tsa', line=dict(color='red')),\n    row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Tn'] + \n    df['DeltaTn'], mode='lines',showlegend=False , \n    line=dict(color='rgba(0,0,0,0)')),\n                row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Tn'] - \n    df['DeltaTn'], mode='lines',showlegend=False , fill='tonexty', \n    line=dict(color='rgba(0,0,0,0)'), fillcolor='rgba(0,255,0,0.3)'),\n                row=1, col=1)\n    fig.update_yaxes(title_text=\"Temperatura [°C]\", row=1, col=1)\n    return fig\n\n\n\nAl igual que la función anterior, está función fue creada para generar la gráfica de “Radiación”, donde nos visualza un grafico dependiendo los valores ingresados por el usuario, para generar un cálculo en base a ello.\ndef plot_I(dia):\n    fig = make_subplots(rows=1, cols=1)\n    df = dia.iloc[::600]\n    fig.add_trace(go.Scatter(x=df.index, y=df['Ig'], mode='lines', name='Ig'), row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Ib'], mode='lines', name='Ib'), row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Id'], mode='lines', name='Id'), row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Is'], mode='lines', name='Is'), row=1, col=1)\n    fig.update_yaxes(title_text=\"Irradiancia [W/m²]\", row=1, col=1)\n    return fig\n\n\n\nEsta función fue creada para generar una nueva línea llamada Ti, para la comprobación de que al momento de que el usuario de clic al botón “Correr”, esta función sea llamada y así por cada sistema constructivo se calcula y genera una nueva Ti.\ndef plot_T_TI(dia):\n    fig = make_subplots(rows=1, cols=1)\n    df = dia.iloc[::600]\n    fig.add_trace(go.Scatter(x=df.index, y=df['Ta'], \n    mode='lines', name='Ta', line=dict(color='black')), \n    row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Tsa'], \n    mode='lines', name='Tsa', line=dict(color='red')),\n    row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Ti'], \n    mode='lines', name='Ti', line=dict(color='green')), \n    row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Tn'] + \n    df['DeltaTn'], mode='lines',showlegend=False , \n    line=dict(color='rgba(0,0,0,0)')),\n                row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Tn'] - \n    df['DeltaTn'], mode='lines',showlegend=False , \n    fill='tonexty', line=dict(color='rgba(0,0,0,0)'), \n    fillcolor='rgba(0,255,0,0.3)'),\n                row=1, col=1)\n    fig.update_yaxes(title_text=\"Temperatura [°C]\", row=1, col=1)\n    return fig\n\n\n\n\n\n\nTomando en cuenta que todas las función descritas anteriormente, es necesario que se rendericen en el server del sistema.",
    "crumbs": [
      "Funciones generales"
    ]
  },
  {
    "objectID": "include/funciones.html#función-para-cargar-las-características-.ini",
    "href": "include/funciones.html#función-para-cargar-las-características-.ini",
    "title": "Funciones generales",
    "section": "",
    "text": "Se generó una función para obtener todo el contenido del archivo de lugares .ini, donde dicho contenido será utilizado para la elaboración de los gráficos y maipulación de datos en el DataFrame.\ndef cargar_caracteristicas(lugar):\n    lugar_config = config[lugar]\n    return {\n        \"lat\": lugar_config.getfloat('lat'),\n        \"lon\": lugar_config.getfloat('lon'),\n        \"alt\": lugar_config.getint('altitude'),\n        \"epw\": lugar_config['f_epw']\n}",
    "crumbs": [
      "Funciones generales"
    ]
  },
  {
    "objectID": "include/funciones.html#función-para-obtener-la-ruta-del-archivo-epw",
    "href": "include/funciones.html#función-para-obtener-la-ruta-del-archivo-epw",
    "title": "Funciones generales",
    "section": "",
    "text": "La siguiente función se creó para obtener la ruta del archivo EPW, que contiene cada lugar. Está función extrae del archivo luagres.ini, la característica “f_epw” la ruta del EPW, para que al momento de que el usuario seleccione el lugar se extraíga el EPW correcto del lugar en específico.\ndef ruta(lugar):\n    f_epw = cargar_caracteristicas(lugar)\n    epwP = f_epw['epw']\n    divi = epwP.split(\"_\")\n    pa = divi[0].replace('data/', '')\n    pais = pa.capitalize()\n    es = divi[1]\n    estado = es.capitalize()\n    ciudad = divi[2].replace('.epw', '')\n    ruta = f\"./data/{pa}_{es}_{ciudad}.epw\"\n    return ruta",
    "crumbs": [
      "Funciones generales"
    ]
  },
  {
    "objectID": "include/funciones.html#función-para-generar-los-inputs-de-controls_left",
    "href": "include/funciones.html#función-para-generar-los-inputs-de-controls_left",
    "title": "Funciones generales",
    "section": "",
    "text": "La función que se muestra a continuación es para crear los inputs del apartado “Cambios”, con los cuales el usuario podrá interactuar con ellos para simular en base a sus necesidades. Validando que tipo de sistema constructivo el usuario desea realizar (“Homogéno o No homogéneo”).\ndef controls_left(type,lugares,meses_dict, location, orientacion,absortance):\n    if type == 1 :\n        return ui.TagList(\n            ui.input_select(\"place\", \"Lugar:\", \n            choices=lugares),\n            ui.input_selectize(\"periodo\", \"Mes:\", \n            choices=list(meses_dict.keys())),\n            ui.input_select(\"ubicacion\", \"Ubicación:\", \n            choices=list(location.keys())),\n            ui.output_ui(\"ubicacion_orientacion\")\n        )\n    elif type == 2 :\n        return ui.TagList(\n            ui.input_select(\"place\", \"Lugar:\", \n            choices=lugares),\n            ui.input_selectize(\"periodo\", \"Mes:\", \n            choices=list(meses_dict.keys())),\n            ui.input_select(\"ubicacion\", \"Ubicación:\", \n            choices=list(location.keys())),\n            ui.input_select(\"orientacion\", \"Orientación:\", \n            choices=list(orientacion.keys())),\n            ui.input_select(\"absortancia\",\"Absortancia:\", \n            choices=list(absortance.keys())),\n            ui.output_ui(\"absortancia_f\"),\n        )\n    return None",
    "crumbs": [
      "Funciones generales"
    ]
  },
  {
    "objectID": "include/funciones.html#función-para-ocultar-la-orientación",
    "href": "include/funciones.html#función-para-ocultar-la-orientación",
    "title": "Funciones generales",
    "section": "",
    "text": "Esta función se generó para que al momento de validar la ubicación la orientación se mostrará o se ocultará. Al igual que se manda a llamar una nueva función “absortancia_f”.\ndef orientacion_disable(ubicacion,  orientacion, absortance):\n    if ubicacion == \"Techo\":\n        return ui.TagList(\n                ui.input_select(\"absortancia\", \"Absortancia:\", \n                choices=list(absortance.keys())),\n                ui.output_ui(\"absortancia_f\")\n            ) \n    else: \n        return ui.TagList(\n                ui.input_select(\"orientacion\", \"Orientación:\", \n                choices=list(orientacion.keys())),\n                ui.input_select(\"absortancia\", \"Absortancia:\", \n                choices=list(absortance.keys())),\n                ui.output_ui(\"absortancia_f\")\n        )",
    "crumbs": [
      "Funciones generales"
    ]
  },
  {
    "objectID": "include/funciones.html#función-para-colocar-el-valor-de-absortancia",
    "href": "include/funciones.html#función-para-colocar-el-valor-de-absortancia",
    "title": "Funciones generales",
    "section": "",
    "text": "Esta función genera un input numérico para que al momento de que la Abosortancia se muestre, el valor predeterminado por tipo de material así como la opción de seleccionar de Absortancia en caso de que no se tenga en la lista mostrada.\ndef absortance_value(value):\n        return ui.TagList(\n            ui.input_numeric(\"absortancia_value\", \"\", \n            value=value, min=0.10, max=1.0, step=0.01)  \n        )",
    "crumbs": [
      "Funciones generales"
    ]
  },
  {
    "objectID": "include/funciones.html#función-para-generar-los-inputs-de-top_controls",
    "href": "include/funciones.html#función-para-generar-los-inputs-de-top_controls",
    "title": "Funciones generales",
    "section": "",
    "text": "Esta función muestra nuevos inputs para la sección de acordeón “Selección”, en base al tipo de sistema constructivo.\ndef top_controls(type):\n    if type == 1:\n        return ui.TagList(\n            ui.input_select(\"Conditional\", \"Condición:\", \n            choices=[\"Sin aire acondicionado\", \"Con aire acondicionado\"]),  \n        )\n    elif type == 2:\n        return ui.TagList(\n            ui.input_slider(\"capas\", \"Número de capas:\", 1, 5, 1),\n            ui.input_select(\"Conditional\", \"Condición:\", \n            choices=[\"Sin aire acondicionado\", \"Con aire acondicionado\"]),\n        )\n    return None",
    "crumbs": [
      "Funciones generales"
    ]
  },
  {
    "objectID": "include/funciones.html#función-para-generar-los-inputs-de-rigth_controls",
    "href": "include/funciones.html#función-para-generar-los-inputs-de-rigth_controls",
    "title": "Funciones generales",
    "section": "",
    "text": "La siguiente función al igual que las anteriores, en base al tipo de sistema, se crean nuevas funciones o nuevos inputs. Para el tipo de sistema con capa homogénea, renderiza a una nueva función llamada “campos” y para el tipo de sistema sin capa homogéna (aún en desarrollo), se generan una lista de inputs.\ndef rigth_controls(type, materiales):\n    if type == 1:\n        return ui.TagList(\n            ui.output_ui(\"campos\")\n        )\n    elif type == 2:\n        return ui.TagList(\n            ui.HTML('&lt;img src=\"modelo.png\" \n            width=\"200\" height=\"90\"&gt;'),\n            ui.input_select(\"muro\", \"Material:\", \n            choices=materiales),\n            ui.layout_columns(\n                ui.input_numeric(\"e11\", \"e11\", value=0.1),\n                ui.input_numeric(\"a11\", \"a11\", value=0.1),\n            ),\n            ui.layout_columns(\n                ui.input_numeric(\"e21\", \"e21\", value=0.1),\n                ui.input_numeric(\"a21\", \"a21\", value=0.1),\n            ),\n            ui.layout_columns(\n                ui.input_numeric(\"e12\", \"e12\", value=0.1),\n                ui.input_numeric(\"a12\", \"a12\", value=0.1),\n            ),\n        )\n    return None",
    "crumbs": [
      "Funciones generales"
    ]
  },
  {
    "objectID": "include/funciones.html#función-para-generar-el-número-de-sistemas",
    "href": "include/funciones.html#función-para-generar-el-número-de-sistemas",
    "title": "Funciones generales",
    "section": "",
    "text": "En esta función se genera la cantidad máx. de 5 sistemas constructivos, al momento de que el usuario ponga un número no válido de sistemas, se le mostrará un modal de error, donde le indique que solo se le permiten de 1 a 5 sistemas. Y si el usuario ingresa una cantidad correcta, entonces la función le genera el número que haya seleccionado, en una sección de acordeón nueva para cada sistema, donde contendrá un input numérico para seleccionar la cantidad de capas por sistema.\n\n\n\n\n\n\nSe 5 listas para generar la sección de acordeón por sistema (SC1,SC2,SC3,SC4,SC5)\n\n\n\ndef f_sistemas(num):\n    if num &gt; 5 or num &lt; 1 or num is None:\n        modal_content = \"Solo se permiten entre 1 y 5 \n        sistemas constructivos.\"\n        modal = ui.modal(modal_content, title=\"Error\", \n        easy_close=True)\n        ui.modal_show(modal)\n        return\n    else:\n        SC1 = ui.TagList(\n            ui.accordion(\n                ui.accordion_panel(\n                    \"Sistema constructivo 1:\",\n                    ui.input_numeric(\"capa_1\", \n                    \"Numero de capas:\", value=1, min=1, max=7),\n                    ui.output_ui(\"num_capas1\")\n                )\n            )\n        )\n        if num == 1:\n            return SC1\n        elif num == 2:\n            return SC1 + SC2\n        elif num == 3:\n            return SC1 + SC2 + SC3\n        elif num == 4:\n            return SC1 + SC2 + SC3 + SC4\n        elif num == 5:\n            return SC1 + SC2 + SC3 + SC4 + SC5",
    "crumbs": [
      "Funciones generales"
    ]
  },
  {
    "objectID": "include/funciones.html#función-para-generar-el-número-de-capas-por-sistema",
    "href": "include/funciones.html#función-para-generar-el-número-de-capas-por-sistema",
    "title": "Funciones generales",
    "section": "",
    "text": "Esta función genera la cantidad de capas por sistema que el usuario haya registrado en el input de la función anterior, validando el limíte del número de capas, al igual que la función anterior si el usuario ingresa un número no válido, entonces se mostrará un modal de error indicandole que ingrese el número correcto.\n\n\n\n\n\n\nSe generaron 5 funciones para cada sistema, teniendo la misma información solo cambiando el id de los inputs.\n\n\n\ndef info_capa1(capa, materiales, sistemas):\n    if capa &gt; 7 or capa &lt; 1 or capa is None:\n        modal_content = \"Solo se permiten entre 1 y 7 capas.\"\n        modal = ui.modal(modal_content, title=\"Error\", \n        easy_close=True)\n        ui.modal_show(modal)\n        return\n    else:\n        capas_ui = []\n        for i in range(capa):\n            capas_ui.append(\n                ui.layout_columns(\n                    ui.input_numeric(f\"espesor_SC1_{i+1}\", \n                    f\"Espesor {i+1} SC 1:\", value=0.010, max=0.9, \n                    step=0.01, min=0.010),\n                    ui.input_select(f\"material_SC1_{i+1}\", \n                    f\"Material {i+1} SC 1:\", choices=materiales)\n                )\n            )\n        return ui.TagList(*capas_ui) if capas_ui else ui.TagList()",
    "crumbs": [
      "Funciones generales"
    ]
  },
  {
    "objectID": "include/funciones.html#función-para-generar-temperatura",
    "href": "include/funciones.html#función-para-generar-temperatura",
    "title": "Funciones generales",
    "section": "",
    "text": "Está función fue creada para generar la gráfica de “Temperatura”, donde nos visualza un grafico dependiendo los valores ingresados por el usuario, para generar un cálculo en base a ello.\ndef plot_T(dia):\n    fig = make_subplots(rows=1, cols=1)\n    df = dia.iloc[::600]\n    fig.add_trace(go.Scatter(x=df.index, y=df['Ta'], \n    mode='lines', name='Ta', line=dict(color='black'))\n    , row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Tsa'], \n    mode='lines', name='Tsa', line=dict(color='red')),\n    row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Tn'] + \n    df['DeltaTn'], mode='lines',showlegend=False , \n    line=dict(color='rgba(0,0,0,0)')),\n                row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Tn'] - \n    df['DeltaTn'], mode='lines',showlegend=False , fill='tonexty', \n    line=dict(color='rgba(0,0,0,0)'), fillcolor='rgba(0,255,0,0.3)'),\n                row=1, col=1)\n    fig.update_yaxes(title_text=\"Temperatura [°C]\", row=1, col=1)\n    return fig",
    "crumbs": [
      "Funciones generales"
    ]
  },
  {
    "objectID": "include/funciones.html#función-para-generar-radiación",
    "href": "include/funciones.html#función-para-generar-radiación",
    "title": "Funciones generales",
    "section": "",
    "text": "Al igual que la función anterior, está función fue creada para generar la gráfica de “Radiación”, donde nos visualza un grafico dependiendo los valores ingresados por el usuario, para generar un cálculo en base a ello.\ndef plot_I(dia):\n    fig = make_subplots(rows=1, cols=1)\n    df = dia.iloc[::600]\n    fig.add_trace(go.Scatter(x=df.index, y=df['Ig'], mode='lines', name='Ig'), row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Ib'], mode='lines', name='Ib'), row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Id'], mode='lines', name='Id'), row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Is'], mode='lines', name='Is'), row=1, col=1)\n    fig.update_yaxes(title_text=\"Irradiancia [W/m²]\", row=1, col=1)\n    return fig",
    "crumbs": [
      "Funciones generales"
    ]
  },
  {
    "objectID": "include/funciones.html#función-para-generar-una-nueva-línea-ti",
    "href": "include/funciones.html#función-para-generar-una-nueva-línea-ti",
    "title": "Funciones generales",
    "section": "",
    "text": "Esta función fue creada para generar una nueva línea llamada Ti, para la comprobación de que al momento de que el usuario de clic al botón “Correr”, esta función sea llamada y así por cada sistema constructivo se calcula y genera una nueva Ti.\ndef plot_T_TI(dia):\n    fig = make_subplots(rows=1, cols=1)\n    df = dia.iloc[::600]\n    fig.add_trace(go.Scatter(x=df.index, y=df['Ta'], \n    mode='lines', name='Ta', line=dict(color='black')), \n    row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Tsa'], \n    mode='lines', name='Tsa', line=dict(color='red')),\n    row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Ti'], \n    mode='lines', name='Ti', line=dict(color='green')), \n    row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Tn'] + \n    df['DeltaTn'], mode='lines',showlegend=False , \n    line=dict(color='rgba(0,0,0,0)')),\n                row=1, col=1)\n    fig.add_trace(go.Scatter(x=df.index, y=df['Tn'] - \n    df['DeltaTn'], mode='lines',showlegend=False , \n    fill='tonexty', line=dict(color='rgba(0,0,0,0)'), \n    fillcolor='rgba(0,255,0,0.3)'),\n                row=1, col=1)\n    fig.update_yaxes(title_text=\"Temperatura [°C]\", row=1, col=1)\n    return fig\n\n\n\n\n\n\nTomando en cuenta que todas las función descritas anteriormente, es necesario que se rendericen en el server del sistema.",
    "crumbs": [
      "Funciones generales"
    ]
  },
  {
    "objectID": "include/bd.html",
    "href": "include/bd.html",
    "title": "Configuración de la base de datos",
    "section": "",
    "text": "Los datos que se contiene en la función, cambian en relación a la configuración que se genere al descargar MySQl, puesto que puede contener o no una contraseña e incluso puede ser diferente. En relación a dicha función es esencial y es la principal para poder hacer inserciones a la base de datos.\ndb_config = {\n    'user': 'root',\n    'password': 'root',\n    'host': 'localhost',\n    'database': 'enerhabitat',\n    'port': 3306\n}\n\n\nEsta función fue creada para generar la inserción de cada simulación que se genere en la base de datos. Principalmente se creó para el usuario administrador, puesto que es almacenada cada simulación que se tenga anual, mensual y por condición (“con aire acondicionado & Sin aire acondicionado”).\ndef insert_db(type, condition, bd):\n    if bd is False:\n        print(\"La ejecución de la base de datos se apagó\")\n    else:\n        connection = mysql.connector.connect(**db_config)\n        cursor = connection.cursor()\n        query = \"\"\"\n        INSERT INTO simulations (id_num, date_count, type_simulation, \n        type_conditional)\n        VALUES (%s, %s, %s, %s);\n        \"\"\"\n        params = (0, date_time.date(), type, condition)\n        cursor.execute(query, params)\n        connection.commit()\n        cursor.close()\n        connection.close()",
    "crumbs": [
      "Base de datos"
    ]
  },
  {
    "objectID": "include/bd.html#insertar-el-conteo-en-la-base-de-datos",
    "href": "include/bd.html#insertar-el-conteo-en-la-base-de-datos",
    "title": "Configuración de la base de datos",
    "section": "",
    "text": "Esta función fue creada para generar la inserción de cada simulación que se genere en la base de datos. Principalmente se creó para el usuario administrador, puesto que es almacenada cada simulación que se tenga anual, mensual y por condición (“con aire acondicionado & Sin aire acondicionado”).\ndef insert_db(type, condition, bd):\n    if bd is False:\n        print(\"La ejecución de la base de datos se apagó\")\n    else:\n        connection = mysql.connector.connect(**db_config)\n        cursor = connection.cursor()\n        query = \"\"\"\n        INSERT INTO simulations (id_num, date_count, type_simulation, \n        type_conditional)\n        VALUES (%s, %s, %s, %s);\n        \"\"\"\n        params = (0, date_time.date(), type, condition)\n        cursor.execute(query, params)\n        connection.commit()\n        cursor.close()\n        connection.close()",
    "crumbs": [
      "Base de datos"
    ]
  },
  {
    "objectID": "include/bd.html#instalación-de-mysql-en-linux",
    "href": "include/bd.html#instalación-de-mysql-en-linux",
    "title": "Configuración de la base de datos",
    "section": "Instalación de MySQL en Linux",
    "text": "Instalación de MySQL en Linux\nAbre una nueva terminal, e ingresar lo siguiente:\n## Comando para instalar mysql\nsudo apt-get install mysql-server\n\n## comando para verificar la instalación\nmysql --version",
    "crumbs": [
      "Base de datos"
    ]
  },
  {
    "objectID": "include/bd.html#acceder-a-mysql-desde-la-terminal",
    "href": "include/bd.html#acceder-a-mysql-desde-la-terminal",
    "title": "Configuración de la base de datos",
    "section": "Acceder a MySQL desde la terminal",
    "text": "Acceder a MySQL desde la terminal\n## Entramos al super usuario\nsudo su\n\n## Ingresar a MySQL\nmysql -u root -p\nComo al instalar MySQL no se colocó una contraseña, no se coloca nada cuando pide la contraseña, solo debes darle enter y podrás entrar.\n## Actualizar para poder descargar\napt update\napt upgrade",
    "crumbs": [
      "Base de datos"
    ]
  },
  {
    "objectID": "include/bd.html#instalación-de-worbeench",
    "href": "include/bd.html#instalación-de-worbeench",
    "title": "Configuración de la base de datos",
    "section": "Instalación de Worbeench",
    "text": "Instalación de Worbeench\nPara eso debemos buscar a “Ubuntu software”, la tienda de aplicaciones. Y buscamos “workbeench” para descargar MySQL Workbeench Community e instalamos.\nUna vez instalado, debemos ingresar en la parte de “Permisos”, para darle permiso de leer, agregar, cambiar, o remover contraseñas.\n\nUna vez instalado, volvemos a la terminal en modo super usuario:",
    "crumbs": [
      "Base de datos"
    ]
  },
  {
    "objectID": "include/bd.html#configuración-para-mysql",
    "href": "include/bd.html#configuración-para-mysql",
    "title": "Configuración de la base de datos",
    "section": "Configuración para MySQL",
    "text": "Configuración para MySQL\nLa contraseña y/o usuario puede ser cambiado a elección, sin embargo tanto como el usuario y la contraseña, no deben ser olvidadas y estas deben ser colocadas en la parte de configuración de la base de datos.\nusuario = root servidor = localhost password = 123456\n## Ingresamos a MySQL\nmysql -u root -p \n\n## Creamos el usuario root y su respectiva contraseña\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';\nAl momento de realizar lo anterior, para usar MySQL desde Workbeench la aplicación anterior de Workbeench se abre y se coloca la contraseña que se creó desde la terminal\n\n\n\n\n\n\nTutorial",
    "crumbs": [
      "Base de datos"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "include/archivos.html",
    "href": "include/archivos.html",
    "title": "Archivos generados",
    "section": "",
    "text": "Para poder generar un código limpio con una estructura legible, se crearon varios archivos, pero de los más destacados y que tienen una función esencial en el sistema, son los siguientes archivos que almacenan información de la cual será extraida en la sección de “funciones generales”.\n\n\nEstos dos archivos generados tienen por nombre lugares.ini & materiales.ini, donde se almacenaran los valores que contiene cada lugar y cada material para después extraerse.\n## Archivo de lugares.ini\n[Cuernavaca, Mor, Mex]\nlat = 18.8\nlon = -99.2\naltitude = 1280\nf_epw = data/MEX_MOR_Cuernavaca.epw\n\n[Zacatepec, Mor, Mex]\nlat = 18.5\nlon = -99.5\naltitude = 1480\nf_epw = data/MEX_MOR_Zacatepec.epw\n## Archivo de materiales.ini\n\n[Cuernavaca, Mor, Mex]\nlat = 18.8\nlon = -99.2\naltitude = 1280\nf_epw = data/MEX_MOR_Cuernavaca.epw\n\n[Zacatepec, Mor, Mex]\nlat = 18.5\nlon = -99.5\naltitude = 1480\nf_epw = data/MEX_MOR_Zacatepec.epw\n\n\n\nEstos archivos contienen los datos que serán usados para poder calcular y generar las simulaciones correctamente, ya que contienen datos meteorológicos que se utilizan comúnmente en simulaciones energéticas y de rendimiento ambiental,para modelar las condiciones climáticas de un sitio específico.\nEjemplo de archivos EPW:",
    "crumbs": [
      "Archivos creados"
    ]
  },
  {
    "objectID": "include/archivos.html#archivos-.ini-lugares-materiales",
    "href": "include/archivos.html#archivos-.ini-lugares-materiales",
    "title": "Archivos generados",
    "section": "",
    "text": "Estos dos archivos generados tienen por nombre lugares.ini & materiales.ini, donde se almacenaran los valores que contiene cada lugar y cada material para después extraerse.\n## Archivo de lugares.ini\n[Cuernavaca, Mor, Mex]\nlat = 18.8\nlon = -99.2\naltitude = 1280\nf_epw = data/MEX_MOR_Cuernavaca.epw\n\n[Zacatepec, Mor, Mex]\nlat = 18.5\nlon = -99.5\naltitude = 1480\nf_epw = data/MEX_MOR_Zacatepec.epw\n## Archivo de materiales.ini\n\n[Cuernavaca, Mor, Mex]\nlat = 18.8\nlon = -99.2\naltitude = 1280\nf_epw = data/MEX_MOR_Cuernavaca.epw\n\n[Zacatepec, Mor, Mex]\nlat = 18.5\nlon = -99.5\naltitude = 1480\nf_epw = data/MEX_MOR_Zacatepec.epw",
    "crumbs": [
      "Archivos creados"
    ]
  },
  {
    "objectID": "include/archivos.html#arcivos-epw",
    "href": "include/archivos.html#arcivos-epw",
    "title": "Archivos generados",
    "section": "",
    "text": "Estos archivos contienen los datos que serán usados para poder calcular y generar las simulaciones correctamente, ya que contienen datos meteorológicos que se utilizan comúnmente en simulaciones energéticas y de rendimiento ambiental,para modelar las condiciones climáticas de un sitio específico.\nEjemplo de archivos EPW:",
    "crumbs": [
      "Archivos creados"
    ]
  },
  {
    "objectID": "include/diccionaries.html",
    "href": "include/diccionaries.html",
    "title": "Diccionarios",
    "section": "",
    "text": "Un diccionario en Python es una estructura de datos que permite almacenar pares de clave-valor. Cada clave en un diccionario es única y se usa para acceder al valor asociado. Los diccionarios son muy versátiles y se utilizan comúnmente para representar datos estructurados y realizar búsquedas rápidas.\n\nA continuación se mostrarán la lista de diccionarios que se crearon para la funcionalidad del sistema:\n\n\nEste diccionario se generó para mostrar al usuario la lista de los meses y a la vez obtener su valor para generar los graficos dependiendo el mes que se seleccione.\nmeses_dict = {\n    \"Enero\": \"01\",\n    \"Febrero\": \"02\",\n    \"Marzo\": \"03\",\n    \"Abril\": \"04\",\n    \"Mayo\": \"05\",\n    \"Junio\": \"06\",\n    \"Julio\": \"07\",\n    \"Agosto\": \"08\",\n    \"Septiembre\": \"09\",       \n    \"Octubre\": \"10\",\n    \"Noviembre\": \"11\",\n    \"Diciembre\": \"12\",\n}\nA continuación se muestra su uso en el sistema:\n\n\n\n\n\n\nAl igual que el diccionario anterior, su funcionalidad es que el texto (clave), se mostrará al usuario para que este pudiera seleccionar la absortancia de su preferencia para realizar el cálculo en base al valor que contenga.\nAbsortancia = {\n    \"Aluminio pulido (0.10)\": 0.10,\n    \"Aluminio oxidado (0.15)\": 0.15,\n    \"Impermeabilizante o pintura blanca nueva (0.15)\": 0.15,\n    \"Impermeabilizante o pintura blanca (0.20)\": 0.20,\n    \"Pintura aluminio (0.2)\": 0.2,\n    \"Lámina galvanizada brillante (0.25)\": 0.25,\n    \"Pintura colores claros (0.3)\": 0.3,\n    \"Recubrimiento elastomérico blanco (0.30)\": 0.30,\n    \"Acero (0.45)\" : 0.45,\n    \"Pintura colores intermedios (0.50)\": 0.50,\n    \"Concreto claro o adocreto claro (0.60)\": 0.60,\n    \"Ladrillo rojo (0.65)\": 0.65,\n    \"Impermeabilizante rojo terracota (0.70)\": 0.70,\n    \"Lámina galvanizada (0.7)\": 0.7,\n    \"Pintura colores oscuros (0.7)\": 0.7,\n    \"Teja roja (0.7)\": 0.7,\n    \"Concreto (0.7)\": 0.7,\n    \"Impermeabilizante o pintura negra (0.90)\": 0.90,\n    \"Asfalto nuevo (0.95)\": 0.95,\n    \"Impermeabilizante o pintura negra mate nueva (0.95)\": 0.95,\n}\nA continuación se muestra su uso en el sistema:\n\n\n\n\n\n\nPor último se crearon los diccionarios correspondientes a la ubicación del sistema constructivo, orientación del mismo y el tipo de sistema a analizar.\nlocation={\n    \"Muro\": 90,\n    \"Techo\": 0,\n}\n\norientacion = {\n    \"Norte\": 0,\n    \"Noreste\": 45,\n    \"Este\": 90, \n    \"Sureste\": 135, \n    \"Sur\": 180,\n    \"Suroeste\": 225, \n    \"Oeste\": 270, \n    \"Noroeste\": 315,\n}\n\ntype_sistem = {\n    \"Con capa homogenea\" : 1,\n    \"Sin capa homogenea\" : 2,\n}\nA continuación se muestra su uso en el sistema:",
    "crumbs": [
      "Diccionarios"
    ]
  },
  {
    "objectID": "include/diccionaries.html#diccionario-para-seleccionar-el-mes",
    "href": "include/diccionaries.html#diccionario-para-seleccionar-el-mes",
    "title": "Diccionarios",
    "section": "",
    "text": "Este diccionario se generó para mostrar al usuario la lista de los meses y a la vez obtener su valor para generar los graficos dependiendo el mes que se seleccione.\nmeses_dict = {\n    \"Enero\": \"01\",\n    \"Febrero\": \"02\",\n    \"Marzo\": \"03\",\n    \"Abril\": \"04\",\n    \"Mayo\": \"05\",\n    \"Junio\": \"06\",\n    \"Julio\": \"07\",\n    \"Agosto\": \"08\",\n    \"Septiembre\": \"09\",       \n    \"Octubre\": \"10\",\n    \"Noviembre\": \"11\",\n    \"Diciembre\": \"12\",\n}\nA continuación se muestra su uso en el sistema:",
    "crumbs": [
      "Diccionarios"
    ]
  },
  {
    "objectID": "include/diccionaries.html#diccionario-para-la-absortancia",
    "href": "include/diccionaries.html#diccionario-para-la-absortancia",
    "title": "Diccionarios",
    "section": "",
    "text": "Al igual que el diccionario anterior, su funcionalidad es que el texto (clave), se mostrará al usuario para que este pudiera seleccionar la absortancia de su preferencia para realizar el cálculo en base al valor que contenga.\nAbsortancia = {\n    \"Aluminio pulido (0.10)\": 0.10,\n    \"Aluminio oxidado (0.15)\": 0.15,\n    \"Impermeabilizante o pintura blanca nueva (0.15)\": 0.15,\n    \"Impermeabilizante o pintura blanca (0.20)\": 0.20,\n    \"Pintura aluminio (0.2)\": 0.2,\n    \"Lámina galvanizada brillante (0.25)\": 0.25,\n    \"Pintura colores claros (0.3)\": 0.3,\n    \"Recubrimiento elastomérico blanco (0.30)\": 0.30,\n    \"Acero (0.45)\" : 0.45,\n    \"Pintura colores intermedios (0.50)\": 0.50,\n    \"Concreto claro o adocreto claro (0.60)\": 0.60,\n    \"Ladrillo rojo (0.65)\": 0.65,\n    \"Impermeabilizante rojo terracota (0.70)\": 0.70,\n    \"Lámina galvanizada (0.7)\": 0.7,\n    \"Pintura colores oscuros (0.7)\": 0.7,\n    \"Teja roja (0.7)\": 0.7,\n    \"Concreto (0.7)\": 0.7,\n    \"Impermeabilizante o pintura negra (0.90)\": 0.90,\n    \"Asfalto nuevo (0.95)\": 0.95,\n    \"Impermeabilizante o pintura negra mate nueva (0.95)\": 0.95,\n}\nA continuación se muestra su uso en el sistema:",
    "crumbs": [
      "Diccionarios"
    ]
  },
  {
    "objectID": "include/diccionaries.html#diccionarios-ubicación-orientación-y-tipo-de-sistema",
    "href": "include/diccionaries.html#diccionarios-ubicación-orientación-y-tipo-de-sistema",
    "title": "Diccionarios",
    "section": "",
    "text": "Por último se crearon los diccionarios correspondientes a la ubicación del sistema constructivo, orientación del mismo y el tipo de sistema a analizar.\nlocation={\n    \"Muro\": 90,\n    \"Techo\": 0,\n}\n\norientacion = {\n    \"Norte\": 0,\n    \"Noreste\": 45,\n    \"Este\": 90, \n    \"Sureste\": 135, \n    \"Sur\": 180,\n    \"Suroeste\": 225, \n    \"Oeste\": 270, \n    \"Noroeste\": 315,\n}\n\ntype_sistem = {\n    \"Con capa homogenea\" : 1,\n    \"Sin capa homogenea\" : 2,\n}\nA continuación se muestra su uso en el sistema:",
    "crumbs": [
      "Diccionarios"
    ]
  },
  {
    "objectID": "include/inicio.html",
    "href": "include/inicio.html",
    "title": "Desarrollo de Ener-Habitat",
    "section": "",
    "text": "Este sistema fue desarrollado con el sistema operativo Linux de Ubuntu 22.04.4, en conjunto con la herramienta de Shiny con un enfoque para Python para la elaboración de funciones y de la interfaz.\n\nBrevemente se describirá la herramienta que se utilizó:\n\n\nEsta herramienta es eficaz, reactiva y robusta, Shiny es de ejecución reactiva, dicha funcionalidad sirve para que los resultados se renderizen solo cuando cambian sus componentes ascendentes, capaz de admitir todo desde aplicaciones web simples a complejas (Foundation, Python, 2023).\nUna aplicación Shiny enfocada en Python es “una página web interactiva (ui) impulsada por una sesión de Python en vivo ejecutada por un servidor”, esto permite que los usuarios pueden manipular la interfaz de manera que el servidor actualice las pantallas del usuario mediante la ejecución de código Python, (CC BY SA Posit Software, 2024).",
    "crumbs": [
      "Desarrollo de Ener-Habitat"
    ]
  },
  {
    "objectID": "include/inicio.html#shiny-para-python",
    "href": "include/inicio.html#shiny-para-python",
    "title": "Desarrollo de Ener-Habitat",
    "section": "",
    "text": "Esta herramienta es eficaz, reactiva y robusta, Shiny es de ejecución reactiva, dicha funcionalidad sirve para que los resultados se renderizen solo cuando cambian sus componentes ascendentes, capaz de admitir todo desde aplicaciones web simples a complejas (Foundation, Python, 2023).\nUna aplicación Shiny enfocada en Python es “una página web interactiva (ui) impulsada por una sesión de Python en vivo ejecutada por un servidor”, esto permite que los usuarios pueden manipular la interfaz de manera que el servidor actualice las pantallas del usuario mediante la ejecución de código Python, (CC BY SA Posit Software, 2024).",
    "crumbs": [
      "Desarrollo de Ener-Habitat"
    ]
  },
  {
    "objectID": "include/server.html",
    "href": "include/server.html",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Las siguientes funciones se generaron para ser visualizadas(renderizadas) por el usuario, debido a que las funciones que se mostrarán y explicarán a continuación van dentro de la función server, las cuales estarán en iteracción con el usuario.\n\n\nLa función server en Shiny para Python define cómo la aplicación responde a las interacciones del usuario y genera salidas dinámicas, haciendo que la aplicación sea interactiva y reactiva.\ndef server(input, output, session):\n\n\n\nLa función que se muestra a continuación es llamada para ser mostrado al comienzo del sistema, la cual visualizará un modal de inicio, dependiendo si está en True o en False. Si la función está en False, entonces el modal de inicio no se mostrará, más si está en True entonces lo podremos visualizar.\n    present_news(False)\n\n\n\nEsta función tiene un evento al momento de que el botón “update”, se seleccione. El evento que realiza esta función es que obtenga el número de veces que se dió clic al botón para poder hacer un conteo de las simulaciones realizadas, donde la función de inserción a la base de datos es llamada, al igual que el tipo de sistema que el usuario seleccionó y la condición (“Con aire acondicionado & Sin aire acondicionado”).\n    @reactive.effect\n    @reactive.event(input.update)\n    def increment():\n        type = input.type()\n        condition = input.Conditional() \n        bd = True\n        insert_db(type, condition,bd)\n\n\n\nLa función generá un nuevo data para agregar la línea Ti, al momento de que el botón sea presionado. Para que se generé el nuevo data, se necesita obtener el valor de las variables que se muestran en la función.\nreactive_data = reactive.Value(pd.DataFrame(columns=['Fecha_Hora']))\n\n    @reactive.effect\n    def _():\n        req(input.update())\n        place = input.place()\n        ruta_epw = ruta(place)\n        mes = meses_dict[input.periodo()]\n        caracteristicas = cargar_caracteristicas(place)\n        absortancia = input.absortancia_value()\n        surface_tilt = location[input.ubicacion()]\n        surface_azimuth = orientacion[input.orientacion()]\n        \n        dia = btn_run(\n            ruta_epw,\n            caracteristicas['lat'],\n            caracteristicas['lon'],\n            caracteristicas['alt'],\n            mes,\n            absortancia,\n            surface_tilt,\n            surface_azimuth,\n            timezone  \n        )\n        \n        reactive_data.set(dia)\n\n\n\nEsta función renderiza y/o retorna a otra función que en este caso tiene por nombre “controls_left”, a la cual se le da el tipo de sistema, lugar, mes, ubicación, orientación y la absortancia que el usuario seleccione, para poder agregar los inputs correspodientes a la validación de la función renderizada.\n    @output\n    @render.ui\n    def left_controls():\n        type = type_sistem[input.type()]\n        return controls_left(type, \n                        lugares, \n                        meses_dict, \n                        location, \n                        orientacion, \n                        Absortancia)\n\n\n\nEsta función renderiza la función que dependiendoo a la ubicación seleccionada por el usuario, la orientación será mostrada u ocultada.\n    @output\n    @render.ui\n    def ubicacion_orientacion():\n        ubicacion = input.ubicacion()\n        return orientacion_disable(ubicacion, \n        orientacion, Absortancia)\n\n\n\nAl igual que lo anterior, la siguiente función renderiza (visualiza) la abortancia seleccionada por el usuario para ser visualizado el valor de la misma en el input numérico que se creó.\n    @output\n    @render.ui\n    def absortancia_f():\n        selected = input.absortancia()\n        value = Absortancia.get(selected, 0.01)\n        return absortance_value(value)\n\n\n\nEsta función retorna la función que genera la sección “Selección”\n    @output\n    @render.ui\n    def controls_top():\n        type =  type_sistem[input.type()]\n        return top_controls(type)\n\n\n\nLa siguiente función muestra al usuario la sección “Datos”, donde depende al tipo de sistema se genera la sección con inputs.\n    @output\n    @render.ui\n    def controls_rigth():\n        type =  type_sistem[input.type()]\n        return rigth_controls(type, materiales)\n\n\n\nAl igual que lo anterior, dependiendo al numero de sistemas que el usuario seleccione entonces la función llamada es la que genera los sistemas con el input para determinar la cantidad de capas.\n    @output\n    @render.ui\n    def campos():\n        num = input.sistemas()\n        return f_sistemas(num)\n\n\n\nEsta función complementa lo anterior, que es mandar a llamar a la función “info_capa#” para generar las capas ingresadas por el usuario,\n    @output\n    @render.ui\n    def num_capas1():\n        sistemas = input.sistemas() \n        capa = input.capa_1()\n        return info_capa1(capa,materiales,sistemas)\n\n\n\nLa siguiente función visualiza la gráfica “Temperatura”, donde se obtienen los datos necesarios para poder generar el gráfico, haciendo el cálculo correcto.\n    @output\n    @render_plotly\n    def temperatura():\n        place = input.place()\n        ruta_epw = ruta(place)\n        mes = meses_dict[input.periodo()]\n        caracteristicas = cargar_caracteristicas(place)\n        absortancia = input.absortancia_value() \n        surface_tilt = location[input.ubicacion()]  \n        surface_azimuth = orientacion[input.orientacion()] \n\n        if input.update():\n            dia =btn_run(\n                ruta_epw,\n                caracteristicas['lat'],\n                caracteristicas['lon'],\n                caracteristicas['alt'],\n                mes,\n                absortancia,\n                surface_tilt,\n                surface_azimuth,\n                timezone\n            )\n            \n            fig = plot_T_I(dia)\n        else:\n            dia = calculate_day(\n                ruta_epw,\n                caracteristicas['lat'],\n                caracteristicas['lon'],\n                caracteristicas['alt'],\n                mes,\n                absortancia,\n                surface_tilt,\n                surface_azimuth,\n                timezone\n            )\n\n            fig = plot_T(dia)\n\n        return fig\n\n\n\nEsta función visualiza la gráfica “Radiación” generada en la función “plot_I”, la cual contiene parametros para poder generar los cálculos correctos para la elaboración de la misma, dependiendo los datos que el usuario ingrese.\n    @output\n    @render_plotly\n    def radiacion():\n        place = input.place()\n        ruta_epw = ruta(place)\n        mes = meses_dict[input.periodo()]\n        caracteristicas = cargar_caracteristicas(place)\n        absortancia = input.absortancia_value() \n        surface_tilt = location[input.ubicacion()] \n        surface_azimuth = orientacion[input.orientacion()]\n\n        dia = calculate_day(\n            ruta_epw,\n            caracteristicas['lat'],\n            caracteristicas['lon'],\n            caracteristicas['alt'],\n            mes,\n            absortancia,\n            surface_tilt,\n            surface_azimuth,\n            timezone\n        )\n        \n        fig = plot_I(dia)\n        return fig\n\n\n\nEsta función muestra el valor de cada elemento que el usuario interectuará, esto con el motivo de conocer que el todo estaba funcionando correctamente.\n\n\n\n\n\n\nEsta función aún esta en desarrollo, no es la final.\n\n\n\n    @output\n    @render.text\n    def resultados():\n        lugar = input.place()\n        mes = input.periodo()\n        ubicacion = input.ubicacion()\n        orienta = input.orientacion()\n        abs = input.absortancia()\n        sistemas = input.sistemas()\n        condicion = input.Conditional()\n        tipo =  type_sistem[input.type()]\n\n        resultado = f\"Lugar: {lugar}, Mes: {mes}, \n        Ubicacion: {ubicacion}, Orientacion: {orienta}, \n        Absortancia: {abs}, Sistemas: {sistemas}, \n        Condicion: {condicion}, Tipo de sistema: {tipo}\"\n\n        return resultado\n\n\n\nEsta función muestra los datos que contiene el DataFrame en una tabla, dependiendo de si el usuario da clic al botón, entonces los datos + la línea Ti graficada se mostrará, pero si el botón no es seleccionado, entonces se mostrará el DataFrame que se uso para graficar “Temperatura & Radiación”. Insertando una columna para index, donde me diga la fecha junto con la hora.\n    @output\n    @render.data_frame\n    def get_day_data():\n        if input.update():\n            result = reactive_data.get()\n            data_to_show = result[::3600].reset_index()\n            data_to_show['Fecha_Hora'] = data_to_show['Fecha_Hora'].dt.strftime('%Y-%m-%d %H:%M:%S')\n        else:\n            place = input.place()\n            ruta_epw = ruta(place)  \n            mes = meses_dict[input.periodo()]  \n            caracteristicas = cargar_caracteristicas(place)  \n            absortancia = Absortancia[input.absortancia()]  \n            surface_tilt = location[input.ubicacion()] \n            surface_azimuth = orientacion[input.orientacion()]  \n        \n            result = data_frame(\n                ruta_epw,\n                caracteristicas['lat'],\n                caracteristicas['lon'],\n                caracteristicas['alt'],\n                mes,\n                absortancia,\n                surface_tilt,\n                surface_azimuth,\n                timezone\n            )\n            \n            data_to_show = result[::3600].reset_index() \n            data_to_show['Fecha_Hora'] = data_to_show['Fecha_Hora'].dt.strftime('%Y-%m-%d %H:%M:%S')\n\n        return data_to_show\n\n\n\nEsta función permité que al momento de que el usuario da clic al botón de descarga que está en la sección de “Datos”, donde se muestra el DataFrame, los datos que se contienen se descargarán en CSV, al igual que si se agrega la línea Ti.\n    @render.download(\n        filename=lambda: f\"data-{date.today().isoformat()}.csv\"\n    )\n    async def downloadData():\n        if input.update():\n            data = reactive_data.get()\n\n            data_= data[::3600].reset_index() \n            csv_buffer = StringIO()\n            data_.to_csv(csv_buffer,index=True)\n            csv_buffer.seek(0)\n        else: \n            place = input.place()\n            ruta_epw = ruta(place)  \n            mes = meses_dict[input.periodo()]  \n            caracteristicas = cargar_caracteristicas(place) \n            absortancia = Absortancia[input.absortancia()]  \n            surface_tilt = location[input.ubicacion()] \n            surface_azimuth = orientacion[input.orientacion()]  \n\n            data = data_frame(\n                ruta_epw,\n                caracteristicas['lat'],\n                caracteristicas['lon'],\n                caracteristicas['alt'],\n                mes,\n                absortancia,\n                surface_tilt,\n                surface_azimuth,\n                timezone\n            )\n        \n            data_= data[::3600].reset_index() \n            csv_buffer = StringIO()\n            data_.to_csv(csv_buffer,index=True)\n            csv_buffer.seek(0)\n            \n        await asyncio.sleep(0.25)\n        yield csv_buffer.read()\n\n\n\nFunción que visualiza la documentación realizada en HTMLTools. Misma que será modificada para que contenga la documentación del uso del sistema.\n    @output\n    @render.ui\n    def documentacion():\n        return respiratory_diseases_app()\n\n\n\nLas siguientes líneas deben declararse para crear y ejecutar la aplicación web.\napp = App(app_ui, server)\n\nif __name__ == \"__main__\":\n    app.run()",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-server",
    "href": "include/server.html#función-server",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "La función server en Shiny para Python define cómo la aplicación responde a las interacciones del usuario y genera salidas dinámicas, haciendo que la aplicación sea interactiva y reactiva.\ndef server(input, output, session):",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-del-modal-de-presentación",
    "href": "include/server.html#función-del-modal-de-presentación",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "La función que se muestra a continuación es llamada para ser mostrado al comienzo del sistema, la cual visualizará un modal de inicio, dependiendo si está en True o en False. Si la función está en False, entonces el modal de inicio no se mostrará, más si está en True entonces lo podremos visualizar.\n    present_news(False)",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-contar-las-simulaciones",
    "href": "include/server.html#función-para-contar-las-simulaciones",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Esta función tiene un evento al momento de que el botón “update”, se seleccione. El evento que realiza esta función es que obtenga el número de veces que se dió clic al botón para poder hacer un conteo de las simulaciones realizadas, donde la función de inserción a la base de datos es llamada, al igual que el tipo de sistema que el usuario seleccionó y la condición (“Con aire acondicionado & Sin aire acondicionado”).\n    @reactive.effect\n    @reactive.event(input.update)\n    def increment():\n        type = input.type()\n        condition = input.Conditional() \n        bd = True\n        insert_db(type, condition,bd)",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-generar-la-línea-ti",
    "href": "include/server.html#función-para-generar-la-línea-ti",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "La función generá un nuevo data para agregar la línea Ti, al momento de que el botón sea presionado. Para que se generé el nuevo data, se necesita obtener el valor de las variables que se muestran en la función.\nreactive_data = reactive.Value(pd.DataFrame(columns=['Fecha_Hora']))\n\n    @reactive.effect\n    def _():\n        req(input.update())\n        place = input.place()\n        ruta_epw = ruta(place)\n        mes = meses_dict[input.periodo()]\n        caracteristicas = cargar_caracteristicas(place)\n        absortancia = input.absortancia_value()\n        surface_tilt = location[input.ubicacion()]\n        surface_azimuth = orientacion[input.orientacion()]\n        \n        dia = btn_run(\n            ruta_epw,\n            caracteristicas['lat'],\n            caracteristicas['lon'],\n            caracteristicas['alt'],\n            mes,\n            absortancia,\n            surface_tilt,\n            surface_azimuth,\n            timezone  \n        )\n        \n        reactive_data.set(dia)",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-visualizar-left_controls",
    "href": "include/server.html#función-para-visualizar-left_controls",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Esta función renderiza y/o retorna a otra función que en este caso tiene por nombre “controls_left”, a la cual se le da el tipo de sistema, lugar, mes, ubicación, orientación y la absortancia que el usuario seleccione, para poder agregar los inputs correspodientes a la validación de la función renderizada.\n    @output\n    @render.ui\n    def left_controls():\n        type = type_sistem[input.type()]\n        return controls_left(type, \n                        lugares, \n                        meses_dict, \n                        location, \n                        orientacion, \n                        Absortancia)",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-visualizar-ubicacion_orientacion",
    "href": "include/server.html#función-para-visualizar-ubicacion_orientacion",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Esta función renderiza la función que dependiendoo a la ubicación seleccionada por el usuario, la orientación será mostrada u ocultada.\n    @output\n    @render.ui\n    def ubicacion_orientacion():\n        ubicacion = input.ubicacion()\n        return orientacion_disable(ubicacion, \n        orientacion, Absortancia)",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-visualizar-el-valor-de-la-abosrtancia",
    "href": "include/server.html#función-para-visualizar-el-valor-de-la-abosrtancia",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Al igual que lo anterior, la siguiente función renderiza (visualiza) la abortancia seleccionada por el usuario para ser visualizado el valor de la misma en el input numérico que se creó.\n    @output\n    @render.ui\n    def absortancia_f():\n        selected = input.absortancia()\n        value = Absortancia.get(selected, 0.01)\n        return absortance_value(value)",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-visualizar-controls_top",
    "href": "include/server.html#función-para-visualizar-controls_top",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Esta función retorna la función que genera la sección “Selección”\n    @output\n    @render.ui\n    def controls_top():\n        type =  type_sistem[input.type()]\n        return top_controls(type)",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-visualizar-controls_rigth",
    "href": "include/server.html#función-para-visualizar-controls_rigth",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "La siguiente función muestra al usuario la sección “Datos”, donde depende al tipo de sistema se genera la sección con inputs.\n    @output\n    @render.ui\n    def controls_rigth():\n        type =  type_sistem[input.type()]\n        return rigth_controls(type, materiales)",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-visualizar-campos",
    "href": "include/server.html#función-para-visualizar-campos",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Al igual que lo anterior, dependiendo al numero de sistemas que el usuario seleccione entonces la función llamada es la que genera los sistemas con el input para determinar la cantidad de capas.\n    @output\n    @render.ui\n    def campos():\n        num = input.sistemas()\n        return f_sistemas(num)",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-visualizar-el-numero-de-capas",
    "href": "include/server.html#función-para-visualizar-el-numero-de-capas",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Esta función complementa lo anterior, que es mandar a llamar a la función “info_capa#” para generar las capas ingresadas por el usuario,\n    @output\n    @render.ui\n    def num_capas1():\n        sistemas = input.sistemas() \n        capa = input.capa_1()\n        return info_capa1(capa,materiales,sistemas)",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-visualizar-la-gráfica-temperatura",
    "href": "include/server.html#función-para-visualizar-la-gráfica-temperatura",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "La siguiente función visualiza la gráfica “Temperatura”, donde se obtienen los datos necesarios para poder generar el gráfico, haciendo el cálculo correcto.\n    @output\n    @render_plotly\n    def temperatura():\n        place = input.place()\n        ruta_epw = ruta(place)\n        mes = meses_dict[input.periodo()]\n        caracteristicas = cargar_caracteristicas(place)\n        absortancia = input.absortancia_value() \n        surface_tilt = location[input.ubicacion()]  \n        surface_azimuth = orientacion[input.orientacion()] \n\n        if input.update():\n            dia =btn_run(\n                ruta_epw,\n                caracteristicas['lat'],\n                caracteristicas['lon'],\n                caracteristicas['alt'],\n                mes,\n                absortancia,\n                surface_tilt,\n                surface_azimuth,\n                timezone\n            )\n            \n            fig = plot_T_I(dia)\n        else:\n            dia = calculate_day(\n                ruta_epw,\n                caracteristicas['lat'],\n                caracteristicas['lon'],\n                caracteristicas['alt'],\n                mes,\n                absortancia,\n                surface_tilt,\n                surface_azimuth,\n                timezone\n            )\n\n            fig = plot_T(dia)\n\n        return fig",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-visualizar-la-gráfica-radiación",
    "href": "include/server.html#función-para-visualizar-la-gráfica-radiación",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Esta función visualiza la gráfica “Radiación” generada en la función “plot_I”, la cual contiene parametros para poder generar los cálculos correctos para la elaboración de la misma, dependiendo los datos que el usuario ingrese.\n    @output\n    @render_plotly\n    def radiacion():\n        place = input.place()\n        ruta_epw = ruta(place)\n        mes = meses_dict[input.periodo()]\n        caracteristicas = cargar_caracteristicas(place)\n        absortancia = input.absortancia_value() \n        surface_tilt = location[input.ubicacion()] \n        surface_azimuth = orientacion[input.orientacion()]\n\n        dia = calculate_day(\n            ruta_epw,\n            caracteristicas['lat'],\n            caracteristicas['lon'],\n            caracteristicas['alt'],\n            mes,\n            absortancia,\n            surface_tilt,\n            surface_azimuth,\n            timezone\n        )\n        \n        fig = plot_I(dia)\n        return fig",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-visualizar-los-resultados",
    "href": "include/server.html#función-para-visualizar-los-resultados",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Esta función muestra el valor de cada elemento que el usuario interectuará, esto con el motivo de conocer que el todo estaba funcionando correctamente.\n\n\n\n\n\n\nEsta función aún esta en desarrollo, no es la final.\n\n\n\n    @output\n    @render.text\n    def resultados():\n        lugar = input.place()\n        mes = input.periodo()\n        ubicacion = input.ubicacion()\n        orienta = input.orientacion()\n        abs = input.absortancia()\n        sistemas = input.sistemas()\n        condicion = input.Conditional()\n        tipo =  type_sistem[input.type()]\n\n        resultado = f\"Lugar: {lugar}, Mes: {mes}, \n        Ubicacion: {ubicacion}, Orientacion: {orienta}, \n        Absortancia: {abs}, Sistemas: {sistemas}, \n        Condicion: {condicion}, Tipo de sistema: {tipo}\"\n\n        return resultado",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-visualizar-el-dataframe",
    "href": "include/server.html#función-para-visualizar-el-dataframe",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Esta función muestra los datos que contiene el DataFrame en una tabla, dependiendo de si el usuario da clic al botón, entonces los datos + la línea Ti graficada se mostrará, pero si el botón no es seleccionado, entonces se mostrará el DataFrame que se uso para graficar “Temperatura & Radiación”. Insertando una columna para index, donde me diga la fecha junto con la hora.\n    @output\n    @render.data_frame\n    def get_day_data():\n        if input.update():\n            result = reactive_data.get()\n            data_to_show = result[::3600].reset_index()\n            data_to_show['Fecha_Hora'] = data_to_show['Fecha_Hora'].dt.strftime('%Y-%m-%d %H:%M:%S')\n        else:\n            place = input.place()\n            ruta_epw = ruta(place)  \n            mes = meses_dict[input.periodo()]  \n            caracteristicas = cargar_caracteristicas(place)  \n            absortancia = Absortancia[input.absortancia()]  \n            surface_tilt = location[input.ubicacion()] \n            surface_azimuth = orientacion[input.orientacion()]  \n        \n            result = data_frame(\n                ruta_epw,\n                caracteristicas['lat'],\n                caracteristicas['lon'],\n                caracteristicas['alt'],\n                mes,\n                absortancia,\n                surface_tilt,\n                surface_azimuth,\n                timezone\n            )\n            \n            data_to_show = result[::3600].reset_index() \n            data_to_show['Fecha_Hora'] = data_to_show['Fecha_Hora'].dt.strftime('%Y-%m-%d %H:%M:%S')\n\n        return data_to_show",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-la-descarga-del-dataframe",
    "href": "include/server.html#función-para-la-descarga-del-dataframe",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Esta función permité que al momento de que el usuario da clic al botón de descarga que está en la sección de “Datos”, donde se muestra el DataFrame, los datos que se contienen se descargarán en CSV, al igual que si se agrega la línea Ti.\n    @render.download(\n        filename=lambda: f\"data-{date.today().isoformat()}.csv\"\n    )\n    async def downloadData():\n        if input.update():\n            data = reactive_data.get()\n\n            data_= data[::3600].reset_index() \n            csv_buffer = StringIO()\n            data_.to_csv(csv_buffer,index=True)\n            csv_buffer.seek(0)\n        else: \n            place = input.place()\n            ruta_epw = ruta(place)  \n            mes = meses_dict[input.periodo()]  \n            caracteristicas = cargar_caracteristicas(place) \n            absortancia = Absortancia[input.absortancia()]  \n            surface_tilt = location[input.ubicacion()] \n            surface_azimuth = orientacion[input.orientacion()]  \n\n            data = data_frame(\n                ruta_epw,\n                caracteristicas['lat'],\n                caracteristicas['lon'],\n                caracteristicas['alt'],\n                mes,\n                absortancia,\n                surface_tilt,\n                surface_azimuth,\n                timezone\n            )\n        \n            data_= data[::3600].reset_index() \n            csv_buffer = StringIO()\n            data_.to_csv(csv_buffer,index=True)\n            csv_buffer.seek(0)\n            \n        await asyncio.sleep(0.25)\n        yield csv_buffer.read()",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#función-para-mostrar-la-documentación",
    "href": "include/server.html#función-para-mostrar-la-documentación",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Función que visualiza la documentación realizada en HTMLTools. Misma que será modificada para que contenga la documentación del uso del sistema.\n    @output\n    @render.ui\n    def documentacion():\n        return respiratory_diseases_app()",
    "crumbs": [
      "Funciones del server"
    ]
  },
  {
    "objectID": "include/server.html#declaraciones-finales",
    "href": "include/server.html#declaraciones-finales",
    "title": "Funciones para las iteracciones",
    "section": "",
    "text": "Las siguientes líneas deben declararse para crear y ejecutar la aplicación web.\napp = App(app_ui, server)\n\nif __name__ == \"__main__\":\n    app.run()",
    "crumbs": [
      "Funciones del server"
    ]
  }
]